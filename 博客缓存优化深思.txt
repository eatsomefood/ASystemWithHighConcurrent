一、先明确评论内容的核心特性（影响缓存策略的关键）
评论内容的特性与视频静态信息、点赞数有显著差异，这些特性决定了缓存设计的侧重点：
数量庞大且增长快：热门文章可能有上万甚至几十万条评论，远超过单篇文章的基础信息（标题、作者等）的数据量。
实时性要求高：用户发布评论后需立即可见，删除 / 修改评论也需快速生效（否则会出现 “评论已删但仍显示” 的问题）。
查询模式复杂：用户通常按 “最新”“最热”（如点赞数高）分页查看，且可能加载 “评论的回复”（嵌套结构），查询条件比 “单纯查点赞数” 更复杂。
冷热分化明显：热门文章的前几页评论被高频访问（热数据），后几十页的历史评论极少被查看（冷数据）；冷门文章的评论几乎无人访问。
二、直接全量缓存评论内容到 Redis 的问题（为什么不推荐）
若简单将所有评论内容（包括文本、作者、时间、点赞数等）全量缓存到 Redis，会面临以下问题：
内存占用过高，性价比低单条评论按 100 字（约 200 字节）计算，10 万条评论需 20MB，1000 篇热门文章就需 20GB，远超 Redis 的合理内存成本（Redis 内存比磁盘贵 10 倍以上）。冷评论（如第 10 页之后）长期占用内存却几乎不被访问，属于资源浪费。
分页与排序难以高效支持评论需按 “时间 / 热度” 分页查询（如 “加载第 2 页最新评论”），若用 Redis 的List或Hash存储，分页时需先获取全部评论再截取（如LRANGE comment:123 20 30），但当评论数超过 1 万时，LRANGE的性能会骤降（Redis 需遍历大量元素）；若用SortedSet按时间戳 / 热度排序，虽支持范围查询（ZRANGEBYSCORE），但每条评论的完整内容仍需额外存储（如Hash），查询时需多次HGET，网络开销大。
缓存一致性维护成本高评论有删除、修改、回复等操作，全量缓存时需实时更新 Redis（否则用户看到旧数据）。例如：用户删除一条评论，需同时删除 Redis 中对应的Hash条目和SortedSet中的 ID，若操作失误（如漏删），会导致缓存与数据库不一致，且排查困难。
三、更优的方案：分层缓存 + 按需加载 + 数据库优化
根据评论的 “冷热分化” 和 “查询模式”，推荐按以下策略设计，平衡性能、成本和一致性：
1. 热数据：Redis 缓存高频访问的评论（前几页 + 热门评论）
针对热门文章的前 3 页评论（用户最常看）、点赞数 Top10 的 “热门评论”，用 Redis 缓存，加速查询：
存储结构设计：
评论 ID 排序集合：用SortedSet存储评论 ID，按 “时间戳”（最新）或 “点赞数”（最热）排序，key 为comment:article:{aid}:sorted:time（时间排序）或comment:article:{aid}:sorted:hot（热度排序），score 为时间戳或点赞数，value 为评论 ID（cid）。
评论详情哈希：用Hash存储单条评论的详情，key 为comment:detail:{cid}，field 包括content（内容）、uid（作者 ID）、like_count（点赞数）、create_time（时间）等。
查询流程：当用户查询 “文章 123 的第 1 页最新评论（20 条）”：
从SortedSet comment:article:123:sorted:time中用ZRANGE取前 20 个cid（ZRANGE ... 0 19）；
用HMGET批量获取这些cid对应的详情（HMGET comment:detail:{cid1} {cid2} ...）；
若缓存未命中（如某条评论的Hash不存在），从数据库查询并补写到 Redis（设置短期过期时间，如 10 分钟）。
更新逻辑：
新评论发布：先写入数据库，再同步到 Redis（ZADD添加 ID 到SortedSet，HSET添加详情）；
评论删除 / 修改：先更新数据库，再删除 Redis 中对应的SortedSet条目和Hash（或直接更新Hash内容）。
2. 冷数据：直接查询数据库，不缓存
对热门文章的第 4 页及以后的评论、冷门文章的所有评论（访问量低），不缓存到 Redis，直接查询数据库：
原因：这些评论访问频率低，缓存的收益（减少数据库查询）不足以覆盖内存成本和维护成本。
数据库优化：
分表存储：按文章 ID（aid）哈希分表（如分 64 张表comment_0至comment_63），避免单表数据量过大（千万级以上）导致查询变慢；
索引优化：针对查询条件建索引，如(aid, create_time)（支持按时间分页）、(aid, like_count, create_time)（支持按热度分页），确保分页查询走索引（SELECT * FROM comment_xx WHERE aid=? ORDER BY create_time DESC LIMIT 20 OFFSET 40）。
3. 评论回复：嵌套结构的特殊处理
若支持 “评论下的回复”（嵌套结构，如 “评论 A 有 10 条回复”），处理方式如下：
回复数量少（<10 条）：随主评论一起缓存（在主评论的Hash中加replies字段，存储回复 ID 列表）；
回复数量多：单独用SortedSet存储回复 ID（按时间排序），key 为comment:reply:{cid}:sorted，查询时按需加载（如 “点击查看更多回复” 时再查询），避免主评论缓存过大。
4. 一致性保障：异步同步 + 过期兜底
写入 / 更新操作：先更新数据库，再同步更新 Redis（若 Redis 更新失败，通过消息队列重试 1-2 次）；
缓存过期：热数据设置短期过期时间（如 10-30 分钟），过期后自动从数据库加载最新数据，避免长期不一致；
冷门文章评论：因不缓存，天然与数据库一致，无需额外处理。
四、总结：不同场景的最佳实践
评论类型	缓存策略	核心目标
热门文章前 3 页评论	Redis 缓存（SortedSet+Hash）	高并发查询加速，<10ms 响应
热门文章第 4 页及以后评论	不缓存，直接查分表数据库	降低内存成本
冷门文章所有评论	不缓存，直接查数据库	避免无效缓存
评论回复	少量随主评论缓存，多量按需加载	平衡嵌套查询性能
这种方案既利用了 Redis 的高并发性能（加速热数据查询），又通过 “不缓存冷数据” 控制内存成本，同时借助数据库分表和索引优化保证冷数据查询效率，是文章评论功能的主流设计模式。